enum Theorem {
    "And.exists",
    "BAll.imp_left",
    "BAll.imp_right",
    "BEx.elim",
    "BEx.imp_left",
    "BEx.imp_right",
    "BEx.intro",
    "CommMagma.IsLeftCancelMul.toIsCancelMul",
    "CommMagma.IsLeftCancelMul.toIsRightCancelMul",
    "CommMagma.IsRightCancelMul.toIsCancelMul",
    "CommMagma.IsRightCancelMul.toIsLeftCancelMul",
    "Commute.smul_left",
    "Commute.smul_right",
    "Decidable.and_forall_ne",
    "Decidable.eq_or_ne",
    "Decidable.ne_or_eq",
    "Eq.rec_eq_cast",
    "Exists.fst",
    "Exists.snd",
    "Exists₂.imp",
    "Exists₃.imp",
    "Fact.elim",
    "Function.Injective.smulCommClass",
    "Function.Surjective.smulCommClass",
    "Iff.ne_left",
    "Iff.ne_right",
    "Iff.not_left",
    "Iff.not_right",
    "Imp.swap",
    "Int.ceil_toNat",
    "Int.floor_toNat",
    "Int.natCast_ceil_eq_ceil",
    "Int.natCast_ceil_eq_ceil_of_neg_one_lt",
    "Int.natCast_floor_eq_floor",
    "IsCentralScalar.unop_smul_eq_smul",
    "IsScalarTower.of_smul_one_mul",
    "MulOneClass.ext",
    "MulOpposite.smul_eq_mul_unop",
    "Nat.ceil_int",
    "Nat.floor_int",
    "Ne.ne_or_ne",
    "Not.imp_symm",
    "Or.elim3",
    "Or.imp3",
    "Prime.coprime_iff_not_dvd",
    "Prime.dvd_mul",
    "Prime.eq_one_or_self_of_dvd",
    "Prime.minFac_eq",
    "Prime.ne_one",
    "Prime.ne_zero",
    "Prime.not_dvd_one",
    "Prime.one_le",
    "Prime.one_lt",
    "Prime.pos",
    "Prime.two_le",
    "Prop.exists_iff",
    "Prop.forall_iff",
    "SMulCommClass.of_commMonoid",
    "SMulCommClass.of_mul_smul_one",
    "SMulCommClass.symm",
    "abs_fract",
    "abs_one_sub_fract",
    "abs_sub_lt_one_of_floor_eq_floor",
    "add_apply",
    "add_lt_add_iff_left",
    "add_one_le_ceil_iff",
    "and_forall_ne",
    "and_iff_not_or_not",
    "and_or_imp",
    "and_symm_left",
    "and_symm_right",
    "apply_dite₂",
    "apply_ite₂",
    "beq_eq_decide",
    "beq_ext",
    "bex_def",
    "by_cases",
    "by_contradiction",
    "card_support_eq_zero",
    "cast_heq_iff_heq",
    "cauchy_add",
    "cauchy_intCast",
    "cauchy_inv",
    "cauchy_mul",
    "cauchy_natCast",
    "cauchy_neg",
    "cauchy_nnratCast",
    "cauchy_one",
    "cauchy_ratCast",
    "cauchy_sub",
    "cauchy_zero",
    "ceil_add_ceil_le",
    "ceil_add_int",
    "ceil_add_le",
    "ceil_add_nat",
    "ceil_add_ofNat",
    "ceil_add_one",
    "ceil_congr",
    "ceil_div_ceil_inv_sub_one",
    "ceil_eq_add_one_sub_fract",
    "ceil_eq_floor_add_one_iff_not_mem",
    "ceil_eq_iff",
    "ceil_eq_on_Ioc",
    "ceil_eq_self_iff_mem",
    "ceil_eq_zero",
    "ceil_eq_zero_iff",
    "ceil_int",
    "ceil_intCast",
    "ceil_le",
    "ceil_le_floor_add_one",
    "ceil_le_mul",
    "ceil_le_two_mul",
    "ceil_lt_add_one",
    "ceil_lt_iff",
    "ceil_lt_mul",
    "ceil_lt_two_mul",
    "ceil_mono",
    "ceil_nat",
    "ceil_natCast",
    "ceil_neg",
    "ceil_nonneg",
    "ceil_nonneg_of_neg_one_lt",
    "ceil_ofNat",
    "ceil_one",
    "ceil_pos",
    "ceil_sub_int",
    "ceil_sub_nat",
    "ceil_sub_ofNat",
    "ceil_sub_one",
    "ceil_sub_self_eq",
    "ceil_zero",
    "choose_eq",
    "coe_eq_zero",
    "coe_equivFunOnFinite_symm",
    "coe_mk",
    "coe_nat_inj",
    "coe_nat_injective",
    "comp.isScalarTower",
    "comp.smulCommClass",
    "comp_smul_left",
    "congr_arg_heq",
    "congr_arg_refl",
    "congr_fun_congr_arg",
    "congr_fun_rfl",
    "congr_heq",
    "congr_refl_left",
    "congr_refl_right",
    "coprime_of_dvd",
    "dec_em",
    "dite_apply",
    "dite_dite_comm",
    "dite_eq_iff",
    "dite_eq_or_eq",
    "dite_mem",
    "dite_ne_left_iff",
    "dite_ne_right_iff",
    "dite_prop_iff_and",
    "dite_prop_iff_or",
    "div_eq_mul_inv",
    "div_mul_cancel",
    "div_self",
    "div_two_lt_floor",
    "dvd_prime",
    "dvd_prime_two_le",
    "em",
    "embDomain_add",
    "embDomain_apply",
    "embDomain_eq_zero",
    "embDomain_inj",
    "embDomain_injective",
    "embDomain_mapRange",
    "embDomain_notin_range",
    "embDomain_zero",
    "eqRec_heq",
    "eq_cast_iff_heq",
    "eq_equivalence",
    "eq_false_intro",
    "eq_inv_of_mul_eq_one_left",
    "eq_ite_iff",
    "eq_or_ne",
    "eq_true_intro",
    "equivFunOnFinite_symm_coe",
    "exists_and_exists_comm",
    "exists_apply_eq",
    "exists_apply_eq_apply",
    "exists_apply_eq_apply2",
    "exists_apply_eq_apply3",
    "exists_iff_of_forall",
    "exists_mem_of_exists",
    "exists_mem_or",
    "exists_mem_or_left",
    "exists_of_exists_mem",
    "exists_or_forall_not",
    "exists_prime_and_dvd",
    "exists_prop_of_false",
    "exists_swap",
    "exists_zpow_surjective",
    "exists₂_comm",
    "ext",
    "ext_cauchy",
    "ext_cauchy_iff",
    "ext_iff",
    "fact_iff",
    "factors_lemma",
    "finite_support",
    "floorRing_ceil_eq",
    "floorRing_floor_eq",
    "floor_add_fract",
    "floor_add_int",
    "floor_add_nat",
    "floor_add_ofNat",
    "floor_add_one",
    "floor_congr",
    "floor_div_eq_div",
    "floor_div_nat",
    "floor_div_ofNat",
    "floor_eq_iff",
    "floor_eq_on_Ico",
    "floor_eq_self_iff_mem",
    "floor_eq_zero",
    "floor_eq_zero_iff",
    "floor_fract",
    "floor_int",
    "floor_intCast",
    "floor_int_add",
    "floor_le",
    "floor_le_ceil",
    "floor_le_iff",
    "floor_le_neg_one_iff",
    "floor_le_of_le",
    "floor_le_one_of_le_one",
    "floor_le_sub_one_iff",
    "floor_lt",
    "floor_lt_ceil_of_lt",
    "floor_lt_ceil_of_lt_of_pos",
    "floor_lt_one",
    "floor_mono",
    "floor_nat",
    "floor_natCast",
    "floor_nat_add",
    "floor_neg",
    "floor_nonneg",
    "floor_nonpos",
    "floor_ofNat",
    "floor_ofNat_add",
    "floor_of_nonpos",
    "floor_one",
    "floor_pos",
    "floor_sub_int",
    "floor_sub_nat",
    "floor_sub_ofNat",
    "floor_sub_one",
    "floor_zero",
    "forall_and_left",
    "forall_and_right",
    "forall_apply_eq_imp_iff",
    "forall_cond_comm",
    "forall_eq_apply_imp_iff",
    "forall_imp_iff_exists_imp",
    "forall_mem_comm",
    "forall_or_exists_not",
    "forall_or_left",
    "forall_or_of_or_forall",
    "forall_or_right",
    "forall_prop_congr",
    "forall_swap",
    "forall_true_iff",
    "forall₂_and",
    "forall₂_imp",
    "forall₂_or_left",
    "forall₂_swap",
    "forall₂_true_iff",
    "forall₃_imp",
    "forall₃_true_iff",
    "fract_add",
    "fract_add_floor",
    "fract_add_fract_le",
    "fract_add_int",
    "fract_add_le",
    "fract_add_nat",
    "fract_add_ofNat",
    "fract_add_one",
    "fract_div_intCast_eq_div_intCast_mod",
    "fract_div_mul_self_add_zsmul_eq",
    "fract_div_mul_self_mem_Ico",
    "fract_div_natCast_eq_div_natCast_mod",
    "fract_eq_fract",
    "fract_eq_iff",
    "fract_eq_self",
    "fract_eq_zero_or_add_one_sub_ceil",
    "fract_floor",
    "fract_fract",
    "fract_int",
    "fract_intCast",
    "fract_int_add",
    "fract_lt_one",
    "fract_mul_nat",
    "fract_natCast",
    "fract_nat_add",
    "fract_neg",
    "fract_neg_eq_zero",
    "fract_nonneg",
    "fract_ofNat",
    "fract_ofNat_add",
    "fract_one",
    "fract_one_add",
    "fract_pos",
    "fract_sub_int",
    "fract_sub_nat",
    "fract_sub_ofNat",
    "fract_sub_one",
    "fract_sub_self",
    "fract_zero",
    "fun_support_eq",
    "gc_ceil_coe",
    "gc_coe_floor",
    "heq_cast_iff_heq",
    "heq_of_eq_cast",
    "heq_rec_iff_heq",
    "if_congr",
    "if_ctx_congr",
    "iff_eq_eq",
    "iff_iff_and_or_not_and_not",
    "iff_iff_not_or_and_or_not",
    "iff_mpr_iff_true_intro",
    "iff_not_comm",
    "image_fract",
    "imp_and_neg_imp_iff",
    "imp_congr_ctx_eq",
    "imp_congr_eq",
    "imp_forall_iff",
    "imp_forall_iff_forall",
    "imp_iff_not_or",
    "imp_iff_or_not",
    "imp_iff_right_iff",
    "imp_or",
    "inv_eq_of_mul_eq_one_left",
    "inv_eq_of_mul_eq_one_right",
    "inv_eq_one_div",
    "inv_inv",
    "inv_mul_cancel",
    "inv_mul_cancel_left",
    "inv_mul_cancel_right",
    "inv_one",
    "inv_smul_smul",
    "irreducible_iff_nat_prime",
    "irreducible_iff_prime",
    "ite_and",
    "ite_apply",
    "ite_eq_iff",
    "ite_eq_or_eq",
    "ite_ite_comm",
    "ite_mem",
    "ite_ne_left_iff",
    "ite_ne_right_iff",
    "ite_or",
    "ite_prop_iff_and",
    "ite_prop_iff_or",
    "lawful_beq_subsingleton",
    "le_ceil",
    "le_ceil_iff",
    "le_floor",
    "le_floor_add",
    "le_floor_add_floor",
    "le_floor_iff",
    "le_minFac",
    "le_mk_of_forall_le",
    "le_of_ceil_le",
    "lt_cauchy",
    "lt_ceil",
    "lt_floor_add_one",
    "lt_floor_iff",
    "lt_of_ceil_lt",
    "lt_of_floor_lt",
    "lt_of_lt_floor",
    "lt_one_of_floor_lt_one",
    "lt_succ_floor",
    "mapRange_add",
    "mapRange_apply",
    "mapRange_comp",
    "mapRange_id",
    "mapRange_injective",
    "mapRange_mapRange",
    "mapRange_neg",
    "mapRange_sub",
    "mapRange_surjective",
    "mapRange_zero",
    "map_ceil",
    "map_floor",
    "map_fract",
    "mem_dite",
    "mem_ite",
    "mem_support_iff",
    "mem_support_onFinset",
    "minFacAux_has_prop",
    "minFac_dvd",
    "minFac_eq",
    "minFac_eq_one_iff",
    "minFac_eq_two_iff",
    "minFac_has_prop",
    "minFac_le",
    "minFac_le_div",
    "minFac_le_of_dvd",
    "minFac_lemma",
    "minFac_one",
    "minFac_pos",
    "minFac_prime",
    "minFac_sq_le_self",
    "minFac_two",
    "minFac_zero",
    "mk_add",
    "mk_const",
    "mk_eq",
    "mk_inf",
    "mk_le",
    "mk_le_of_forall_le",
    "mk_lt",
    "mk_mul",
    "mk_near_of_forall_near",
    "mk_neg",
    "mk_one",
    "mk_pos",
    "mk_sup",
    "mk_zero",
    "mul_add_one_le_add_one_pow",
    "mul_assoc",
    "mul_comm",
    "mul_div_assoc",
    "mul_div_cancel_right",
    "mul_inv_cancel",
    "mul_inv_cancel_comm",
    "mul_inv_cancel_left",
    "mul_inv_cancel_right",
    "mul_inv_rev",
    "mul_left_cancel",
    "mul_left_cancel_iff",
    "mul_left_inj",
    "mul_left_injective",
    "mul_lt_floor",
    "mul_ne_mul_left",
    "mul_ne_mul_right",
    "mul_one",
    "mul_right_cancel",
    "mul_right_cancel_iff",
    "mul_right_inj",
    "mul_right_injective",
    "mul_smul_comm",
    "mul_smul_mul_comm",
    "mul_smul_one",
    "natCast_ceil_eq_intCast_ceil",
    "natCast_ceil_eq_intCast_ceil_of_neg_one_lt",
    "natCast_floor_eq_intCast_floor",
    "ne_and_eq_iff_right",
    "ne_iff",
    "ne_of_eq_of_ne",
    "ne_of_ne_of_eq",
    "ne_or_eq",
    "negSucc_zsmul",
    "neg_apply",
    "not_and_not_right",
    "not_and_or",
    "not_beq_of_ne",
    "not_exists_mem",
    "not_forall_not",
    "not_forall₂",
    "not_forall₂_of_exists₂_not",
    "not_iff",
    "not_iff_comm",
    "not_iff_not",
    "not_imp",
    "not_imp_comm",
    "not_imp_not",
    "not_mem_support_iff",
    "not_ne_iff",
    "not_or_of_imp",
    "not_prime_iff_minFac_lt",
    "not_prime_one",
    "not_prime_zero",
    "npowBinRec.go_spec",
    "npowRec",
    "npowRec_eq",
    "npowRec_eq_npowBinRec",
    "npow_eq_pow",
    "ofCauchy_add",
    "ofCauchy_div",
    "ofCauchy_inf",
    "ofCauchy_intCast",
    "ofCauchy_inv",
    "ofCauchy_mul",
    "ofCauchy_natCast",
    "ofCauchy_neg",
    "ofCauchy_nnratCast",
    "ofCauchy_one",
    "ofCauchy_ratCast",
    "ofCauchy_sub",
    "ofCauchy_sup",
    "ofCauchy_zero",
    "ofRat_rat",
    "ofSupportFinite_coe",
    "of_not_imp",
    "of_not_not",
    "onFinset_apply",
    "one_div",
    "one_le_ceil_iff",
    "one_le_floor_iff",
    "one_mul",
    "one_smul",
    "one_smul_eq_id",
    "op_smul_eq_mul",
    "or_congr_left",
    "or_congr_right",
    "or_iff_not_and_not",
    "or_not",
    "or_not_of_imp",
    "peirce",
    "pos_of_floor_pos",
    "pow_add",
    "pow_mul",
    "pow_mul_comm",
    "pow_one",
    "pow_right_comm",
    "pow_succ",
    "pow_three",
    "pow_zero",
    "preimage_Icc",
    "preimage_Ici",
    "preimage_Ico",
    "preimage_Iic",
    "preimage_Iio",
    "preimage_Ioc",
    "preimage_Ioi",
    "preimage_Ioo",
    "preimage_ceil_of_ne_zero",
    "preimage_ceil_singleton",
    "preimage_ceil_zero",
    "preimage_floor_of_ne_zero",
    "preimage_floor_singleton",
    "preimage_floor_zero",
    "preimage_fract",
    "prime_def",
    "prime_def_le_sqrt",
    "prime_def_lt",
    "prime_def_minFac",
    "prime_dvd_prime_iff_eq",
    "prime_eleven",
    "prime_five",
    "prime_iff",
    "prime_of_coprime",
    "prime_seven",
    "prime_three",
    "prime_two",
    "range_mapRange",
    "ratCast_lt",
    "rec_heq_iff_heq",
    "rec_heq_of_heq",
    "self_sub_floor",
    "self_sub_fract",
    "smul_assoc",
    "smul_div_assoc",
    "smul_eq_mul",
    "smul_inv",
    "smul_inv_smul",
    "smul_iterate",
    "smul_iterate_apply",
    "smul_mul",
    "smul_mul_assoc",
    "smul_mul_smul_comm",
    "smul_one_mul",
    "smul_one_smul",
    "smul_pow",
    "smul_smul",
    "smul_smul_smul_comm",
    "smul_zpow",
    "some_spec₂",
    "sub_apply",
    "sub_floor_div_mul_lt",
    "sub_floor_div_mul_nonneg",
    "sub_one_lt_floor",
    "subsingleton_floorRing",
    "subsingleton_floorSemiring",
    "support_add",
    "support_add_eq",
    "support_embDomain",
    "support_eq_empty",
    "support_mapRange",
    "support_mapRange_of_injective",
    "support_neg",
    "support_nonempty_iff",
    "support_onFinset",
    "support_onFinset_subset",
    "support_sub",
    "support_subset_iff",
    "support_zero",
    "support_zipWith",
    "unique_ext",
    "xor_comm",
    "xor_iff_iff_not",
    "xor_iff_not_iff",
    "xor_iff_or_and_not_and",
    "xor_not_not",
    "zero_apply",
    "zipWith_apply",
    "zpow_natCast",
    "zpow_negSucc",
    "zpow_neg_coe_of_pos",
    "zpow_neg_one",
    "zpow_ofNat",
    "zpow_one"
}

enum OnelineTactic {
    "simp",
    "field_simp",
    "norm_num",
    "ring",
    "ring_nf",
    "omega",
    "linarith",
    "nlinarith"
}

enum AtTactic {
    "rw",
    "rwhat"
}

enum Place {
    "here",
    "before"
}

enum Int {
    "2",
    "3"
}


enum NULL{
    "NULL"
}

value Empty;
value Stmt;
value Bool;


program Lean() -> Bool;
func use_theorem_tactic: Stmt -> AtTactic, Theorem;
func oneline: Stmt -> OnelineTactic;
func delete: Stmt -> NULL;
func nth_rw: Stmt -> Int;
func unfold: Stmt -> NULL;
func checker: Bool -> Stmt, Place;
func empty: Empty -> Empty;
