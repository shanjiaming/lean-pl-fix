enum Theorem {
    "And.exists",
    "BAll.imp_left",
    "BAll.imp_right",
    "BEx.elim",
    "BEx.imp_left",
    "BEx.imp_right",
    "BEx.intro",
    "CommMagma.IsLeftCancelMul.toIsCancelMul",
    "CommMagma.IsLeftCancelMul.toIsRightCancelMul",
    "CommMagma.IsRightCancelMul.toIsCancelMul",
    "CommMagma.IsRightCancelMul.toIsLeftCancelMul",
    "Commute.smul_left",
    "Commute.smul_right",
    "Decidable.and_forall_ne",
    "Decidable.eq_or_ne",
    "Decidable.ne_or_eq",
    "Eq.rec_eq_cast",
    "Exists.fst",
    "Exists.snd",
    "ExistsUnique.elim₂",
    "ExistsUnique.exists₂",
    "ExistsUnique.intro₂",
    "ExistsUnique.unique₂",
    "Exists₂.imp",
    "Exists₃.imp",
    "Fact.elim",
    "Function.End.mul_def",
    "Function.End.one_def",
    "Function.Injective.smulCommClass",
    "Function.Surjective.smulCommClass",
    "Iff.ne_left",
    "Iff.ne_right",
    "Iff.not_left",
    "Iff.not_right",
    "Imp.swap",
    "Int.ceil_toNat",
    "Int.floor_toNat",
    "Int.ofNat_ceil_eq_ceil",
    "Int.ofNat_floor_eq_floor",
    "IsCentralScalar.unop_smul_eq_smul",
    "IsPretransitive.of_compHom",
    "IsPretransitive.of_smul_eq",
    "IsScalarTower.of_smul_one_mul",
    "MulAction.IsPretransitive.of_isScalarTower",
    "MulOneClass.ext",
    "Nat.ceil_int",
    "Nat.floor_int",
    "Ne.ne_or_ne",
    "Not.imp_symm",
    "Or.elim3",
    "Or.imp3",
    "PLift.down_injective",
    "Prop.exists_iff",
    "Prop.forall_iff",
    "SMul.smul_eq_hSMul",
    "SMulCommClass.of_mul_smul_one",
    "SMulCommClass.symm",
    "ULift.down_injective",
    "_root_.AddEquiv.finsuppUnique_symm",
    "abs_fract",
    "abs_one_sub_fract",
    "abs_sub_lt_one_of_floor_eq_floor",
    "abs_sub_round",
    "abs_sub_round_div_natCast_eq",
    "abs_sub_round_eq_min",
    "addHom_ext",
    "add_apply",
    "add_closure_setOf_eq_single",
    "add_lt_add_iff_left",
    "add_one_le_ceil_iff",
    "and_forall_ne",
    "and_iff_not_or_not",
    "and_or_imp",
    "and_symm_left",
    "and_symm_right",
    "apply_dite₂",
    "apply_ite₂",
    "apply_single",
    "ball_of_forall",
    "beq_eq_decide",
    "beq_ext",
    "bex_def",
    "bex_eq_left",
    "by_cases",
    "by_contradiction",
    "card_support_eq_one",
    "card_support_eq_zero",
    "card_support_le_one",
    "cauchy_add",
    "cauchy_intCast",
    "cauchy_inv",
    "cauchy_mul",
    "cauchy_natCast",
    "cauchy_neg",
    "cauchy_nnratCast",
    "cauchy_one",
    "cauchy_ratCast",
    "cauchy_sub",
    "cauchy_zero",
    "ceil_add_ceil_le",
    "ceil_add_int",
    "ceil_add_le",
    "ceil_add_nat",
    "ceil_add_ofNat",
    "ceil_add_one",
    "ceil_congr",
    "ceil_eq_add_one_sub_fract",
    "ceil_eq_iff",
    "ceil_eq_on_Ioc",
    "ceil_eq_zero",
    "ceil_eq_zero_iff",
    "ceil_int",
    "ceil_intCast",
    "ceil_le",
    "ceil_le_ceil",
    "ceil_le_floor_add_one",
    "ceil_lt_add_one",
    "ceil_mono",
    "ceil_nat",
    "ceil_natCast",
    "ceil_neg",
    "ceil_nonneg",
    "ceil_ofNat",
    "ceil_one",
    "ceil_pos",
    "ceil_sub_int",
    "ceil_sub_nat",
    "ceil_sub_ofNat",
    "ceil_sub_one",
    "ceil_sub_self_eq",
    "ceil_zero",
    "coe_eq_zero",
    "coe_mk",
    "coe_update",
    "comp.isScalarTower",
    "comp.smulCommClass",
    "compHom_smul_def",
    "comp_smul_left",
    "congr_arg_heq",
    "congr_arg_refl",
    "congr_fun_congr_arg",
    "congr_fun_rfl",
    "congr_heq",
    "congr_refl_left",
    "congr_refl_right",
    "dec_em",
    "dite_apply",
    "dite_dite_comm",
    "dite_eq_iff",
    "dite_eq_or_eq",
    "dite_ne_left_iff",
    "dite_ne_right_iff",
    "dite_prop_iff_and",
    "dite_prop_iff_or",
    "div_eq_mul_inv",
    "em",
    "embDomain_add",
    "embDomain_apply",
    "embDomain_eq_zero",
    "embDomain_inj",
    "embDomain_injective",
    "embDomain_mapRange",
    "embDomain_notin_range",
    "embDomain_single",
    "embDomain_zero",
    "eqRec_heq",
    "eq_equivalence",
    "eq_false_intro",
    "eq_inv_of_mul_eq_one_left",
    "eq_ite_iff",
    "eq_or_ne",
    "eq_single_iff",
    "eq_true_intro",
    "equivFunOnFinite_single",
    "equivFunOnFinite_symm_coe",
    "equivFunOnFinite_symm_single",
    "erase_add",
    "erase_add_single",
    "erase_apply",
    "erase_eq_sub_single",
    "erase_eq_update_zero",
    "erase_idem",
    "erase_ne",
    "erase_of_not_mem_support",
    "erase_same",
    "erase_single",
    "erase_single_ne",
    "erase_update_of_ne",
    "erase_zero",
    "exists_apply_eq",
    "exists_apply_eq_apply",
    "exists_apply_eq_apply2",
    "exists_apply_eq_apply3",
    "exists_iff_of_forall",
    "exists_mem_of_exists",
    "exists_mem_or",
    "exists_mem_or_left",
    "exists_of_exists_mem",
    "exists_or_forall_not",
    "exists_prop_congr",
    "exists_prop_of_false",
    "exists_prop_of_true",
    "exists_smul_eq",
    "exists_swap",
    "exists_unique_const",
    "exists_unique_prop",
    "exists_unique_prop_of_true",
    "exists₂_comm",
    "exists₂_imp",
    "ext",
    "ext_cauchy",
    "ext_cauchy_iff",
    "ext_iff",
    "fact_iff",
    "finite_support",
    "floorRing_ceil_eq",
    "floorRing_floor_eq",
    "floor_add_fract",
    "floor_add_int",
    "floor_add_nat",
    "floor_add_ofNat",
    "floor_add_one",
    "floor_congr",
    "floor_div_eq_div",
    "floor_div_nat",
    "floor_div_ofNat",
    "floor_eq_iff",
    "floor_eq_on_Ico",
    "floor_eq_zero",
    "floor_eq_zero_iff",
    "floor_fract",
    "floor_int",
    "floor_intCast",
    "floor_int_add",
    "floor_le",
    "floor_le_ceil",
    "floor_le_floor",
    "floor_le_neg_one_iff",
    "floor_le_of_le",
    "floor_le_one_of_le_one",
    "floor_le_sub_one_iff",
    "floor_lt",
    "floor_lt_ceil_of_lt",
    "floor_lt_ceil_of_lt_of_pos",
    "floor_lt_one",
    "floor_mono",
    "floor_nat",
    "floor_natCast",
    "floor_nat_add",
    "floor_neg",
    "floor_nonneg",
    "floor_nonpos",
    "floor_ofNat",
    "floor_ofNat_add",
    "floor_of_nonpos",
    "floor_one",
    "floor_pos",
    "floor_sub_int",
    "floor_sub_nat",
    "floor_sub_ofNat",
    "floor_sub_one",
    "floor_zero",
    "forall_apply_eq_imp_iff",
    "forall_cond_comm",
    "forall_eq_apply_imp_iff",
    "forall_imp_iff_exists_imp",
    "forall_mem_comm",
    "forall_of_ball",
    "forall_or_exists_not",
    "forall_or_left",
    "forall_or_of_or_forall",
    "forall_or_right",
    "forall_prop_congr",
    "forall_swap",
    "forall_true_iff",
    "forall₂_and",
    "forall₂_imp",
    "forall₂_or_left",
    "forall₂_swap",
    "forall₂_true_iff",
    "forall₃_imp",
    "forall₃_true_iff",
    "fract_add",
    "fract_add_floor",
    "fract_add_fract_le",
    "fract_add_int",
    "fract_add_le",
    "fract_add_nat",
    "fract_add_ofNat",
    "fract_add_one",
    "fract_div_intCast_eq_div_intCast_mod",
    "fract_div_mul_self_add_zsmul_eq",
    "fract_div_mul_self_mem_Ico",
    "fract_div_natCast_eq_div_natCast_mod",
    "fract_eq_fract",
    "fract_eq_iff",
    "fract_eq_self",
    "fract_eq_zero_or_add_one_sub_ceil",
    "fract_floor",
    "fract_fract",
    "fract_int",
    "fract_intCast",
    "fract_int_add",
    "fract_lt_one",
    "fract_mul_nat",
    "fract_natCast",
    "fract_nat_add",
    "fract_neg",
    "fract_neg_eq_zero",
    "fract_nonneg",
    "fract_ofNat",
    "fract_ofNat_add",
    "fract_one",
    "fract_one_add",
    "fract_pos",
    "fract_sub_int",
    "fract_sub_nat",
    "fract_sub_ofNat",
    "fract_sub_one",
    "fract_sub_self",
    "fract_zero",
    "fun_support_eq",
    "gc_ceil_coe",
    "gc_coe_floor",
    "heq_rec_iff_heq",
    "iff_eq_eq",
    "iff_iff_and_or_not_and_not",
    "iff_iff_not_or_and_or_not",
    "iff_mpr_iff_true_intro",
    "iff_not_comm",
    "image_fract",
    "imp_and_neg_imp_iff",
    "imp_congr_ctx_eq",
    "imp_congr_eq",
    "imp_forall_iff",
    "imp_iff_not_or",
    "imp_iff_or_not",
    "imp_iff_right_iff",
    "imp_or",
    "induction_linear",
    "induction₂",
    "inv_eq_of_mul_eq_one_left",
    "inv_eq_of_mul_eq_one_right",
    "inv_inv",
    "inv_mul_cancel_left",
    "inv_mul_cancel_right",
    "inv_mul_self",
    "inv_one",
    "isPretransitive_compHom",
    "ite_and",
    "ite_apply",
    "ite_eq_iff",
    "ite_eq_or_eq",
    "ite_ite_comm",
    "ite_ne_left_iff",
    "ite_ne_right_iff",
    "ite_prop_iff_and",
    "ite_prop_iff_or",
    "lawful_beq_subsingleton",
    "le_ceil",
    "le_floor",
    "le_floor_add",
    "le_floor_add_floor",
    "le_floor_iff",
    "le_mk_of_forall_le",
    "le_of_ceil_le",
    "lt_cauchy",
    "lt_ceil",
    "lt_floor_add_one",
    "lt_of_ceil_lt",
    "lt_of_floor_lt",
    "lt_of_lt_floor",
    "lt_one_of_floor_lt_one",
    "lt_succ_floor",
    "mapRange_add",
    "mapRange_apply",
    "mapRange_comp",
    "mapRange_id",
    "mapRange_neg",
    "mapRange_single",
    "mapRange_sub",
    "mapRange_zero",
    "map_ceil",
    "map_floor",
    "map_fract",
    "map_round",
    "mem_support_iff",
    "mem_support_onFinset",
    "mem_support_single",
    "mk_add",
    "mk_eq",
    "mk_inf",
    "mk_le",
    "mk_le_of_forall_le",
    "mk_lt",
    "mk_mul",
    "mk_near_of_forall_near",
    "mk_neg",
    "mk_one",
    "mk_pos",
    "mk_sup",
    "mk_zero",
    "mulHom_ext",
    "mul_assoc",
    "mul_comm",
    "mul_inv_cancel_comm",
    "mul_inv_cancel_left",
    "mul_inv_cancel_right",
    "mul_inv_rev",
    "mul_inv_self",
    "mul_left_cancel",
    "mul_left_cancel_iff",
    "mul_left_inv",
    "mul_one",
    "mul_right_cancel",
    "mul_right_cancel_iff",
    "mul_right_inv",
    "mul_smul_comm",
    "mul_smul_one",
    "natCast_ceil_eq_intCast_ceil",
    "natCast_floor_eq_intCast_floor",
    "ne_and_eq_iff_right",
    "ne_iff",
    "ne_of_eq_of_ne",
    "ne_of_ne_of_eq",
    "ne_or_eq",
    "negSucc_zsmul",
    "neg_apply",
    "not_and_not_right",
    "not_and_or",
    "not_beq_of_ne",
    "not_exists_mem",
    "not_forall_not",
    "not_forall₂",
    "not_forall₂_of_exists₂_not",
    "not_iff",
    "not_iff_comm",
    "not_iff_not",
    "not_imp",
    "not_imp_comm",
    "not_imp_not",
    "not_mem_support_iff",
    "not_ne_iff",
    "not_or_of_imp",
    "npow_eq_pow",
    "ofCauchy_add",
    "ofCauchy_div",
    "ofCauchy_inf",
    "ofCauchy_intCast",
    "ofCauchy_inv",
    "ofCauchy_mul",
    "ofCauchy_natCast",
    "ofCauchy_neg",
    "ofCauchy_nnratCast",
    "ofCauchy_one",
    "ofCauchy_ratCast",
    "ofCauchy_sub",
    "ofCauchy_sup",
    "ofCauchy_zero",
    "ofRat_rat",
    "ofSupportFinite_coe",
    "of_not_imp",
    "of_not_not",
    "onFinset_apply",
    "one_le_ceil_iff",
    "one_le_floor_iff",
    "one_mul",
    "one_smul",
    "one_smul_eq_id",
    "or_congr_left",
    "or_congr_right",
    "or_iff_not_and_not",
    "or_not",
    "or_not_of_imp",
    "or_of_or_of_imp_left",
    "or_of_or_of_imp_of_imp",
    "or_of_or_of_imp_right",
    "peirce",
    "pi_congr",
    "pos_of_floor_pos",
    "pow_add",
    "pow_mul",
    "pow_mul_comm",
    "pow_one",
    "pow_right_comm",
    "pow_succ",
    "pow_three",
    "pow_zero",
    "preimage_Icc",
    "preimage_Ici",
    "preimage_Ico",
    "preimage_Iic",
    "preimage_Iio",
    "preimage_Ioc",
    "preimage_Ioi",
    "preimage_Ioo",
    "preimage_ceil_of_ne_zero",
    "preimage_ceil_singleton",
    "preimage_ceil_zero",
    "preimage_floor_of_ne_zero",
    "preimage_floor_singleton",
    "preimage_floor_zero",
    "preimage_fract",
    "range_single_subset",
    "ratCast_lt",
    "rec_heq_iff_heq",
    "rec_heq_of_heq",
    "round_add_int",
    "round_add_nat",
    "round_add_ofNat",
    "round_add_one",
    "round_eq",
    "round_eq_zero_iff",
    "round_intCast",
    "round_int_add",
    "round_le",
    "round_natCast",
    "round_nat_add",
    "round_neg_two_inv",
    "round_ofNat",
    "round_ofNat_add",
    "round_one",
    "round_sub_int",
    "round_sub_nat",
    "round_sub_ofNat",
    "round_sub_one",
    "round_two_inv",
    "round_zero",
    "self_sub_floor",
    "self_sub_fract",
    "single_add",
    "single_add_erase",
    "single_add_single_eq_single_add_single",
    "single_apply",
    "single_apply_eq_zero",
    "single_apply_left",
    "single_apply_mem",
    "single_apply_ne_zero",
    "single_eq_of_ne",
    "single_eq_pi_single",
    "single_eq_same",
    "single_eq_set_indicator",
    "single_eq_single_iff",
    "single_eq_update",
    "single_eq_zero",
    "single_injective",
    "single_left_inj",
    "single_left_injective",
    "single_of_embDomain_single",
    "single_of_single_apply",
    "single_swap",
    "single_zero",
    "smul_assoc",
    "smul_div_assoc",
    "smul_eq_mul",
    "smul_left_injective",
    "smul_mul_assoc",
    "smul_mul_smul",
    "smul_one_mul",
    "smul_one_smul",
    "smul_pow",
    "smul_smul",
    "smul_smul_smul_comm",
    "some_spec₂",
    "sub_apply",
    "sub_floor_div_mul_lt",
    "sub_floor_div_mul_nonneg",
    "sub_one_lt_floor",
    "subsingleton_floorRing",
    "subsingleton_floorSemiring",
    "support_add",
    "support_add_eq",
    "support_embDomain",
    "support_eq_empty",
    "support_eq_singleton",
    "support_erase",
    "support_mapRange",
    "support_mapRange_of_injective",
    "support_neg",
    "support_nonempty_iff",
    "support_onFinset",
    "support_onFinset_subset",
    "support_single_disjoint",
    "support_single_ne_bot",
    "support_single_ne_zero",
    "support_single_subset",
    "support_sub",
    "support_subset_iff",
    "support_subset_singleton",
    "support_update",
    "support_update_ne_zero",
    "support_update_subset",
    "support_update_zero",
    "support_zero",
    "support_zipWith",
    "surjective_smul",
    "toFun_apply",
    "unique_ext",
    "unique_ext_iff",
    "unique_single",
    "unique_single_eq_iff",
    "update_comm",
    "update_eq_erase_add_single",
    "update_eq_single_add_erase",
    "update_eq_sub_add_single",
    "update_self",
    "xor_comm",
    "xor_iff_iff_not",
    "xor_iff_not_iff",
    "xor_not_not",
    "zero_apply",
    "zero_update",
    "zipWith_apply",
    "zipWith_single_single",
    "zpow_natCast",
    "zpow_negSucc",
    "zpow_neg_coe_of_pos",
    "zpow_neg_one",
    "zpow_ofNat",
    "zpow_one"
}

enum OnelineTactic {
    "simp",
    "field_simp",
    "norm_num",
    "ring",
    "ring_nf",
    "omega",
    "linarith",
    "nlinarith"
}

enum AtTactic {
    "rw",
    "rwhat"
}

value Empty;
value Str;
value Bool;

program Lean() -> Bool;
func use_theorem_tactic: Str -> AtTactic, Theorem;
func oneline: Str -> OnelineTactic;
func checker: Bool -> Str;
func empty: Empty -> Empty;
