Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 63 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 59 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 67 ms
Completed successfully!
Build completed successfully.
🚀 Processing 9 problems from demo with minimal verification constraint
================================================================================

--- Processing 1/9: demo_complex_p1 ---

🎯 Processing demo/demo_complex_p1 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 5 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_3) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  📊 5 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_2" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_3" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem complex_have_chain (n : ℕ) (h : n > 0) : n + n ≥ n := by
  have h1 : n ≥ 1 := by
    hole_2
  have h2 : n + n ≥ n + 1 := by
    have h3 : n ≥ 1 := h1
    have h4 : n + n = n + n := rfl
    have h5 : n + 1 ≤ n + n := by
      hole_4
    hole_3
  have h6 : n + 1 ≥ n := by
    hole_5
  hole_1
------------------------------------------
📊 ProofStep response received: 5 sorries
  - Server found sorry at position=(12, 4), proof_state=0
  - Server found sorry at position=(17, 6), proof_state=1
  - Server found sorry at position=(18, 4), proof_state=2
  - Server found sorry at position=(20, 4), proof_state=3
  - Server found sorry at position=(21, 2), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 12:5) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 17:7) to server proof_state 1
  ✅ Matched parser sorry_idx 2 (pos 18:5) to server proof_state 2
  ✅ Matched parser sorry_idx 3 (pos 20:5) to server proof_state 3
  ✅ Matched parser sorry_idx 4 (pos 21:3) to server proof_state 4
📊 Correctly matched 5 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_2)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_2
    ✅ linarith succeeded on proof_state 0
  ✅ linarith succeeded on hole_2
🎯 Testing tactics on sorry index 1 (Hole: hole_4)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_4
    ✅ linarith succeeded on proof_state 1
  ✅ linarith succeeded on hole_4
🎯 Testing tactics on sorry index 2 (Hole: hole_3)
    ❌ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_3
    ✅ linarith succeeded on proof_state 2
  ✅ linarith succeeded on hole_3
🎯 Testing tactics on sorry index 3 (Hole: hole_5)
    ✅ norm_num succeeded on proof_state 3
  ✅ norm_num succeeded on hole_5
🎯 Testing tactics on sorry index 4 (Hole: hole_1)
    ✅ norm_num succeeded on proof_state 4
  ✅ norm_num succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_4: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_3: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_5: SOLVED with 'norm_num'
    ✅ norm_num
  - hole_1: SOLVED with 'norm_num'
    ✅ norm_num
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_2 -> linarith
  ✅ hole_4 -> linarith
  ✅ hole_3 -> linarith
  ✅ hole_5 -> norm_num
  ✅ hole_1 -> norm_num
  📊 Replaced 5/5 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 5 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p1/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p1/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: ✅
  Processing time: 11.7s

--- Processing 2/9: demo_complex_p3 ---

🎯 Processing demo/demo_complex_p3 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 1 sorry mappings
    0: hole_i (hole_1) -> ENUM
  📊 1 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_1" : tactic => `(tactic| admit)

theorem contradiction_with_have (a b : ℕ) (h : a + b = 0) : a = 0 ∧ b = 0 := by
  hole_1
------------------------------------------
📊 ProofStep response received: 1 sorries
  - Server found sorry at position=(7, 2), proof_state=0

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 7:3) to server proof_state 0
📊 Correctly matched 1 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_1)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_1
    ❌ linarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
a b : ℕ
h : a + b = 0
⊢ False failed...
  ❌ linarith failed on hole_1
    ❌ nlinarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
a b : ℕ
h : a + b = 0
⊢ False failed...
  ❌ nlinarith failed on hole_1
    ✅ omega succeeded on proof_state 0
  ✅ omega succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 1/1
  Success rate (per sorry): 100.0%
  Total proof state tests: 4
  --- Detailed Tactic Results ---
  - hole_1: SOLVED with 'omega'
    ❌ norm_num
    ❌ linarith
    ❌ nlinarith
    ✅ omega
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_1 -> omega
  📊 Replaced 1/1 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 1 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p3/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p3/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 4
  Successful tactics: 1
  Tactics replaced: 1
  Constraint satisfied: ✅
  Processing time: 11.3s

--- Processing 3/9: demo_complex_p4 ---

🎯 Processing demo/demo_complex_p4 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUMBuild completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 68 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 62 ms
Completed successfully!
Build completed successfully.

    1: hole_i (hole_2) -> ENUM
    2: hole_i (hole_5) -> ENUM
    3: hole_i (hole_4) -> ENUM
    4: hole_i (hole_1) -> ENUM
  📊 5 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem simp_then_have_chain (x y : ℕ) (h : x + 0 = y + 0) : x = y := by
  simp at h
  have h1 : x ≤ y ∨ y ≤ x := le_total x y
  cases' h1 with h_le h_ge
  · 
    have h2 : x = y := by
      have h3 : x ≤ y := h_le
      have h4 : y ≤ x := by
        hole_3
      hole_2
    exact h2
  · 
    have h2 : x = y := by
      have h3 : y ≤ x := h_ge
      have h4 : x ≤ y := by
        hole_5
      hole_4
    hole_1
------------------------------------------
📊 ProofStep response received: 5 sorries
  - Server found sorry at position=(18, 8), proof_state=0
  - Server found sorry at position=(19, 6), proof_state=1
  - Server found sorry at position=(25, 8), proof_state=2
  - Server found sorry at position=(26, 6), proof_state=3
  - Server found sorry at position=(27, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 18:9) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 19:7) to server proof_state 1
  ✅ Matched parser sorry_idx 2 (pos 25:9) to server proof_state 2
  ✅ Matched parser sorry_idx 3 (pos 26:7) to server proof_state 3
  ✅ Matched parser sorry_idx 4 (pos 27:5) to server proof_state 4
📊 Correctly matched 5 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_3)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_3
    ✅ linarith succeeded on proof_state 0
  ✅ linarith succeeded on hole_3
🎯 Testing tactics on sorry index 1 (Hole: hole_2)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_2
    ✅ linarith succeeded on proof_state 1
  ✅ linarith succeeded on hole_2
🎯 Testing tactics on sorry index 2 (Hole: hole_5)
    ❌ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_5
    ✅ linarith succeeded on proof_state 2
  ✅ linarith succeeded on hole_5
🎯 Testing tactics on sorry index 3 (Hole: hole_4)
    ❌ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_4
    ✅ linarith succeeded on proof_state 3
  ✅ linarith succeeded on hole_4
🎯 Testing tactics on sorry index 4 (Hole: hole_1)
    ❌ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_1
    ✅ linarith succeeded on proof_state 4
  ✅ linarith succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 10
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_2: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_5: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_4: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_1: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_3 -> linarith
  ✅ hole_2 -> linarith
  ✅ hole_5 -> linarith
  ✅ hole_4 -> linarith
  ✅ hole_1 -> linarith
  📊 Replaced 5/5 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 5 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p4/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p4/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 10
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: ✅
  Processing time: 12.9s

--- Processing 4/9: demo_complex_p5 ---

🎯 Processing demo/demo_complex_p5 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_2) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  📊 5 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem multi_level_decomposition (a b c : ℕ) (h1 : a ≤ b) (h2 : b ≤ c) : a ≤ c := by
  by_cases h : a = c
  · 
    simp [h]
  · 
    have h_main : a < c := by
      have h3 : a ≤ c := by
        have h4 : a ≤ b := h1
        have h5 : b ≤ c := h2
        have h6 : a ≤ c := le_trans h4 h5
        hole_3
      have h7 : a ≠ c := h
      have h8 : a < c := by
        have h9 : a ≤ c := h3
        have h10 : a ≠ c := h7
        hole_4
      hole_2
    have h_final : a ≤ c := by
      have h11 : a < c := h_main
      have h12 : a ≤ c := le_of_lt h11
      hole_5
    hole_1
------------------------------------------
📊 ProofStep response received: 5 sorries
  - Server found sorry at position=(20, 8), proof_state=0
  - Server found sorry at position=(25, 8), proof_state=1
  - Server found sorry at position=(26, 6), proof_state=2
  - Server found sorry at position=(30, 6), proof_state=3
  - Server found sorry at position=(31, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 20:9) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 25:9) to server proof_state 1
  ✅ Matched parser sorry_idx 2 (pos 26:7) to server proof_state 2
  ✅ Matched parser sorry_idx 3 (pos 30:7) to server proof_state 3
  ✅ Matched parser sorry_idx 4 (pos 31:5) to server proof_state 4
📊 Correctly matched 5 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_3)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_3
    ✅ linarith succeeded on proof_state 0
  ✅ linarith succeeded on hole_3
🎯 Testing tactics on sorry index 1 (Hole: hole_4)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_4
    ❌ linarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case h
a b c : ℕ
h1 : a ≤ b
h2 : b ≤ c
h : ¬a = ...
  ❌ linarith failed on hole_4
    ❌ nlinarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case h
a b c : ℕ
h1 : a ≤ b
h2 : b ≤ c
h : ¬a = ...
  ❌ nlinarith failed on hole_4
    ✅ omega succeeded on proof_state 1
  ✅ omega succeeded on hole_4
🎯 Testing tactics on sorry index 2 (Hole: hole_2)
    ❌ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remainBuild completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 69 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 63 ms
Completed successfully!
Build completed successfully.

  ❌ norm_num failed on hole_2
    ✅ linarith succeeded on proof_state 2
  ✅ linarith succeeded on hole_2
🎯 Testing tactics on sorry index 3 (Hole: hole_5)
    ❌ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_5
    ✅ linarith succeeded on proof_state 3
  ✅ linarith succeeded on hole_5
🎯 Testing tactics on sorry index 4 (Hole: hole_1)
    ❌ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_1
    ✅ linarith succeeded on proof_state 4
  ✅ linarith succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 12
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_4: SOLVED with 'omega'
    ❌ norm_num
    ❌ linarith
    ❌ nlinarith
    ✅ omega
  - hole_2: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_5: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_1: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_3 -> linarith
  ✅ hole_4 -> omega
  ✅ hole_2 -> linarith
  ✅ hole_5 -> linarith
  ✅ hole_1 -> linarith
  📊 Replaced 5/5 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 5 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p5/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p5/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 12
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: ✅
  Processing time: 11.9s

--- Processing 5/9: demo_complex_p6 ---

🎯 Processing demo/demo_complex_p6 with minimal verification
❌ Error processing demo_complex_p6: Decomposition results not found: decomposition_results/demo/decomposed/demo_complex_p6/decomposition.json
Please run the original decomposition pipeline first:
python decompose_hole_merge_pipeline.py problem demo demo_complex_p6

--- Processing 6/9: demo_complex_p2 ---

🎯 Processing demo/demo_complex_p2 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 2 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_1) -> ENUM
  📊 2 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_2" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem case_analysis_simple (n : ℕ) : n = 0 ∨ n > 0 := by
  cases' n with k
  · 
    left
    have h1 : 0 = 0 := rfl
    exact h1
  · 
    right
    have h1 : k + 1 > 0 := by hole_2
    have h2 : Nat.succ k = k + 1 := rfl
    have h3 : k + 1 > 0 := h1
    hole_1
------------------------------------------
📊 ProofStep response received: 2 sorries
  - Server found sorry at position=(15, 30), proof_state=0
  - Server found sorry at position=(18, 4), proof_state=1

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 15:31) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 18:5) to server proof_state 1
📊 Correctly matched 2 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_2)
    ✅ norm_num succeeded on proof_state 0
  ✅ norm_num succeeded on hole_2
🎯 Testing tactics on sorry index 1 (Hole: hole_1)
    ✅ norm_num succeeded on proof_state 1
  ✅ norm_num succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 2/2
  Success rate (per sorry): 100.0%
  Total proof state tests: 2
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'norm_num'
    ✅ norm_num
  - hole_1: SOLVED with 'norm_num'
    ✅ norm_num
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_2 -> norm_num
  ✅ hole_1 -> norm_num
  📊 Replaced 2/2 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 2 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p2/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p2/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 2
  Successful tactics: 2
  Tactics replaced: 2
  Constraint satisfied: ✅
  Processing time: 10.9s

--- Processing 7/9: demo_eq_comm ---

🎯 Processing demo/demo_eq_comm with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: FAIL
  Hole: FAIL
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 2 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_1) -> ENUM
  📊 2 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib


macro "hole_2" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem eq_comm_demo (x y : ℕ) : x = y ↔ y = x := by
  constructor
  · 
    have a: x = y -> y = x := by
      hole_2
    hole_1
------------------------------------------
📊 ProofStep response received: 2 sorries
  - Server found sorry at position=(11, 6), proof_state=0
  - Server found sorry at position=(12, 4), proof_state=1

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 11:7) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 12:5) to server proof_state 1
📊 Correctly matched 2 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_2)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_2
    ❌ linarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
x y : ℕ
⊢ False failed...
  ❌ linarith failed on hole_2
    ❌ nlinarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
x y : ℕ
⊢ False failed...
  ❌ nlinarith failed on hole_2
    ✅ omega succeeded on proof_state 0
  ✅ omega succeeded on hole_2
🎯 Testing tactics on sorry index 1 (Hole: hole_1)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_1
    ❌ linarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case mp
x y : ℕ
a : x = y → y = x
⊢ False failed...
  ❌ linarith failed on hole_1
    ❌ nlinarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case mp
x y : ℕ
a : x = y → y = x
⊢ False failed...
  ❌ nlinarith failed on hole_1
    ✅ omega succeeded on proof_state 1
  ✅ omega succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 2/2
  Success rate (per sorry): 100.0%Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 61 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 87 ms
Completed successfully!
Build completed successfully.

  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'omega'
    ❌ norm_num
    ❌ linarith
    ❌ nlinarith
    ✅ omega
  - hole_1: SOLVED with 'omega'
    ❌ norm_num
    ❌ linarith
    ❌ nlinarith
    ✅ omega
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_2 -> omega
  ✅ hole_1 -> omega
  📊 Replaced 2/2 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 2 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_eq_comm/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: FAIL
  ✨ Complete solve success: False
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_eq_comm/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 2
  Tactics replaced: 2
  Constraint satisfied: ✅
  Processing time: 11.3s

--- Processing 8/9: demo_complex_p7 ---

🎯 Processing demo/demo_complex_p7 with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUM
    1: hole_i (hole_2) -> ENUM
    2: hole_i (hole_5) -> ENUM
    3: hole_i (hole_4) -> ENUM
    4: hole_i (hole_1) -> ENUM
  📊 5 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem simp_then_have_chain (x y : ℕ) (h : x + 0 = y + 0) : x = y := by
  simp at h
  have h1 : x ≤ y ∨ y ≤ x := le_total x y
  cases' h1 with h_le h_ge
  · 
    have h2 : x = y := by
      have h3 : x ≤ y := h_le
      have h4 : y ≤ x := by
        hole_3
      hole_2
    exact h2
  · 
    have h2 : x = y := by
      have h3 : y ≤ x := h_ge
      have h4 : x ≤ y := by
        hole_5
      hole_4
    hole_1
------------------------------------------
📊 ProofStep response received: 5 sorries
  - Server found sorry at position=(18, 8), proof_state=0
  - Server found sorry at position=(19, 6), proof_state=1
  - Server found sorry at position=(25, 8), proof_state=2
  - Server found sorry at position=(26, 6), proof_state=3
  - Server found sorry at position=(27, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 18:9) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 19:7) to server proof_state 1
  ✅ Matched parser sorry_idx 2 (pos 25:9) to server proof_state 2
  ✅ Matched parser sorry_idx 3 (pos 26:7) to server proof_state 3
  ✅ Matched parser sorry_idx 4 (pos 27:5) to server proof_state 4
📊 Correctly matched 5 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_3)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_3
    ✅ linarith succeeded on proof_state 0
  ✅ linarith succeeded on hole_3
🎯 Testing tactics on sorry index 1 (Hole: hole_2)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_2
    ✅ linarith succeeded on proof_state 1
  ✅ linarith succeeded on hole_2
🎯 Testing tactics on sorry index 2 (Hole: hole_5)
    ❌ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_5
    ✅ linarith succeeded on proof_state 2
  ✅ linarith succeeded on hole_5
🎯 Testing tactics on sorry index 3 (Hole: hole_4)
    ❌ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_4
    ✅ linarith succeeded on proof_state 3
  ✅ linarith succeeded on hole_4
🎯 Testing tactics on sorry index 4 (Hole: hole_1)
    ❌ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_1
    ✅ linarith succeeded on proof_state 4
  ✅ linarith succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 10
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_2: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_5: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_4: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_1: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_3 -> linarith
  ✅ hole_2 -> linarith
  ✅ hole_5 -> linarith
  ✅ hole_4 -> linarith
  ✅ hole_1 -> linarith
  📊 Replaced 5/5 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 5 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p7/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p7/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 10
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: ✅
  Processing time: 12.5s

--- Processing 9/9: demo_multiline_have ---

🎯 Processing demo/demo_multiline_have with minimal verification
📋 Loading existing decomposition results...
📊 Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
🧪 ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  🔍 Found 5 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_3) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  📊 5 enumerable holes, 0 skip holes
🚀 Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib

macro "hole_2" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_3" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem multiline_have_test (n : ℕ) (h : n > 0) : n + n ≥ n := by
  have h1 : n ≥ 1 := by
    hole_2
  have h2 : n + n ≥ 
        n + 1 := by
    have h3 : n ≥ 1 := h1
    have h4 : n + n = 
          n + n := rfl
    have h5 : n + 1 ≤ 
        n + n := by
      hole_4
    hole_3
  have h6 : n + 1 ≥ 
      n := by
    hole_5
  hole_1
------------------------------------------
📊 ProofStep response received: 5 sorries
  - Server found sorry at position=(12, 4), proof_state=0
  - Server found sorry at position=(20, 6), proof_state=1
  - Server found sorry at position=(21, 4), proof_state=2
  - Server found sorry at position=(24, 4), proof_state=3
  - Server found sorry at position=(25, 2), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  ✅ Matched parser sorry_idx 0 (pos 12:5) to server proof_state 0
  ✅ Matched parser sorry_idx 1 (pos 20:7) to server proof_state 1
  ✅ Matched parser sorry_idx 2 (pos 21:5) to server proof_state 2
  ✅ Matched parser sorry_idx 3 (pos 24:5) to server proof_state 3
  ✅ Matched parser sorry_idx 4 (pos 25:3) to server proof_state 4
📊 Correctly matched 5 proof states for enumeration.
🎯 Testing tactics on sorry index 0 (Hole: hole_2)
    ❌ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_2
    ✅ linarith succeeded on proof_state 0
  ✅ linarith succeeded on hole_2
🎯 Testing tactics on sorry index 1 (Hole: hole_4)
    ❌ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_4
    ✅ linarith succeeded on proof_state 1
  ✅ linarith succeeded on hole_4
🎯 Testing tactics on sorry index 2 (Hole: hole_3)
    ❌ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  ❌ norm_num failed on hole_3
    ✅ linarith succeeded on proof_state 2
  ✅ linarith succeeded on hole_3
🎯 Testing tactics on sorry index 3 (Hole: hole_5)
    ✅ norm_num succeeded on proof_state 3
  ✅ norm_num succeeded on hole_5
🎯 Testing tactics on sorry index 4 (Hole: hole_1)
    ✅ norm_num succeeded on proof_state 4
  ✅ norm_num succeeded on hole_1
📈 ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_4: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_3: SOLVED with 'linarith'
    ❌ norm_num
    ✅ linarith
  - hole_5: SOLVED with 'norm_num'
    ✅ norm_num
  - hole_1: SOLVED with 'norm_num'
    ✅ norm_num
  Full verifications used: 0/3
📝 Creating synthesized version by directly replacing holes with tactics...
  ✅ hole_2 -> linarith
  ✅ hole_4 -> linarith
  ✅ hole_3 -> linarith
  ✅ hole_5 -> norm_num
  ✅ hole_1 -> norm_num
  📊 Replaced 5/5 hole usages with tactics/admit
  🗂️  Complete tactic mapping: 5 holes mapped
  🎯 No admits used: True
  💾 Synthesized proof saved to: decomposition_results/demo/decomposed/demo_multiline_have/synthesized_proof.lean
🔍 Verification 3: Final synthesized proof
🔍 Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  ✨ Complete solve success: True
  💾 Minimal verification result saved to: decomposition_results/demo/decomposed/demo_multiline_have/minimal_verification.json
📊 Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: ✅
  Processing time: 12.0s
💾 Dataset summary saved to: decomposition_results/demo_minimal_verification_summary.json

================================================================================
🎉 MINIMAL VERIFICATION PIPELINE SUMMARY
Dataset: demo
Problems processed: 9
Constraint violations: 1
Constraint satisfaction rate: 88.9%
Successfully filled proofs: 7
Complete solve success (no admits): 7
Complete solve success rate: 77.8%
Total proof state tests: 62
Total full verifications: 8
Verification efficiency: 7.8 proof state tests per full verification

⚠️  1 constraint violations detected
                                                                                Saving trace data, this could take a while                                                                                Wait for child processes to finish, Ctrl+C to skip                                                                                Loading trace data from processes 0/1