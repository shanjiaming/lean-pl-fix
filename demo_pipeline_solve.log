Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 63 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 59 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 67 ms
Completed successfully!
Build completed successfully.
ğŸš€ Processing 9 problems from demo with minimal verification constraint
================================================================================

--- Processing 1/9: demo_complex_p1 ---

ğŸ¯ Processing demo/demo_complex_p1 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 5 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_3) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  ğŸ“Š 5 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_2" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_3" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem complex_have_chain (n : â„•) (h : n > 0) : n + n â‰¥ n := by
  have h1 : n â‰¥ 1 := by
    hole_2
  have h2 : n + n â‰¥ n + 1 := by
    have h3 : n â‰¥ 1 := h1
    have h4 : n + n = n + n := rfl
    have h5 : n + 1 â‰¤ n + n := by
      hole_4
    hole_3
  have h6 : n + 1 â‰¥ n := by
    hole_5
  hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 5 sorries
  - Server found sorry at position=(12, 4), proof_state=0
  - Server found sorry at position=(17, 6), proof_state=1
  - Server found sorry at position=(18, 4), proof_state=2
  - Server found sorry at position=(20, 4), proof_state=3
  - Server found sorry at position=(21, 2), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 12:5) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 17:7) to server proof_state 1
  âœ… Matched parser sorry_idx 2 (pos 18:5) to server proof_state 2
  âœ… Matched parser sorry_idx 3 (pos 20:5) to server proof_state 3
  âœ… Matched parser sorry_idx 4 (pos 21:3) to server proof_state 4
ğŸ“Š Correctly matched 5 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_2)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_2
    âœ… linarith succeeded on proof_state 0
  âœ… linarith succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_4)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_4
    âœ… linarith succeeded on proof_state 1
  âœ… linarith succeeded on hole_4
ğŸ¯ Testing tactics on sorry index 2 (Hole: hole_3)
    âŒ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_3
    âœ… linarith succeeded on proof_state 2
  âœ… linarith succeeded on hole_3
ğŸ¯ Testing tactics on sorry index 3 (Hole: hole_5)
    âœ… norm_num succeeded on proof_state 3
  âœ… norm_num succeeded on hole_5
ğŸ¯ Testing tactics on sorry index 4 (Hole: hole_1)
    âœ… norm_num succeeded on proof_state 4
  âœ… norm_num succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_4: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_3: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_5: SOLVED with 'norm_num'
    âœ… norm_num
  - hole_1: SOLVED with 'norm_num'
    âœ… norm_num
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_2 -> linarith
  âœ… hole_4 -> linarith
  âœ… hole_3 -> linarith
  âœ… hole_5 -> norm_num
  âœ… hole_1 -> norm_num
  ğŸ“Š Replaced 5/5 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 5 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p1/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p1/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: âœ…
  Processing time: 11.7s

--- Processing 2/9: demo_complex_p3 ---

ğŸ¯ Processing demo/demo_complex_p3 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 1 sorry mappings
    0: hole_i (hole_1) -> ENUM
  ğŸ“Š 1 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_1" : tactic => `(tactic| admit)

theorem contradiction_with_have (a b : â„•) (h : a + b = 0) : a = 0 âˆ§ b = 0 := by
  hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 1 sorries
  - Server found sorry at position=(7, 2), proof_state=0

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 7:3) to server proof_state 0
ğŸ“Š Correctly matched 1 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_1)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_1
    âŒ linarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
a b : â„•
h : a + b = 0
âŠ¢ False failed...
  âŒ linarith failed on hole_1
    âŒ nlinarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
a b : â„•
h : a + b = 0
âŠ¢ False failed...
  âŒ nlinarith failed on hole_1
    âœ… omega succeeded on proof_state 0
  âœ… omega succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 1/1
  Success rate (per sorry): 100.0%
  Total proof state tests: 4
  --- Detailed Tactic Results ---
  - hole_1: SOLVED with 'omega'
    âŒ norm_num
    âŒ linarith
    âŒ nlinarith
    âœ… omega
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_1 -> omega
  ğŸ“Š Replaced 1/1 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 1 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p3/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p3/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 4
  Successful tactics: 1
  Tactics replaced: 1
  Constraint satisfied: âœ…
  Processing time: 11.3s

--- Processing 3/9: demo_complex_p4 ---

ğŸ¯ Processing demo/demo_complex_p4 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUMBuild completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 68 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 62 ms
Completed successfully!
Build completed successfully.

    1: hole_i (hole_2) -> ENUM
    2: hole_i (hole_5) -> ENUM
    3: hole_i (hole_4) -> ENUM
    4: hole_i (hole_1) -> ENUM
  ğŸ“Š 5 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem simp_then_have_chain (x y : â„•) (h : x + 0 = y + 0) : x = y := by
  simp at h
  have h1 : x â‰¤ y âˆ¨ y â‰¤ x := le_total x y
  cases' h1 with h_le h_ge
  Â· 
    have h2 : x = y := by
      have h3 : x â‰¤ y := h_le
      have h4 : y â‰¤ x := by
        hole_3
      hole_2
    exact h2
  Â· 
    have h2 : x = y := by
      have h3 : y â‰¤ x := h_ge
      have h4 : x â‰¤ y := by
        hole_5
      hole_4
    hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 5 sorries
  - Server found sorry at position=(18, 8), proof_state=0
  - Server found sorry at position=(19, 6), proof_state=1
  - Server found sorry at position=(25, 8), proof_state=2
  - Server found sorry at position=(26, 6), proof_state=3
  - Server found sorry at position=(27, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 18:9) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 19:7) to server proof_state 1
  âœ… Matched parser sorry_idx 2 (pos 25:9) to server proof_state 2
  âœ… Matched parser sorry_idx 3 (pos 26:7) to server proof_state 3
  âœ… Matched parser sorry_idx 4 (pos 27:5) to server proof_state 4
ğŸ“Š Correctly matched 5 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_3)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_3
    âœ… linarith succeeded on proof_state 0
  âœ… linarith succeeded on hole_3
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_2)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_2
    âœ… linarith succeeded on proof_state 1
  âœ… linarith succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 2 (Hole: hole_5)
    âŒ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_5
    âœ… linarith succeeded on proof_state 2
  âœ… linarith succeeded on hole_5
ğŸ¯ Testing tactics on sorry index 3 (Hole: hole_4)
    âŒ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_4
    âœ… linarith succeeded on proof_state 3
  âœ… linarith succeeded on hole_4
ğŸ¯ Testing tactics on sorry index 4 (Hole: hole_1)
    âŒ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_1
    âœ… linarith succeeded on proof_state 4
  âœ… linarith succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 10
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_2: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_5: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_4: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_1: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_3 -> linarith
  âœ… hole_2 -> linarith
  âœ… hole_5 -> linarith
  âœ… hole_4 -> linarith
  âœ… hole_1 -> linarith
  ğŸ“Š Replaced 5/5 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 5 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p4/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p4/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 10
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: âœ…
  Processing time: 12.9s

--- Processing 4/9: demo_complex_p5 ---

ğŸ¯ Processing demo/demo_complex_p5 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_2) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  ğŸ“Š 5 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem multi_level_decomposition (a b c : â„•) (h1 : a â‰¤ b) (h2 : b â‰¤ c) : a â‰¤ c := by
  by_cases h : a = c
  Â· 
    simp [h]
  Â· 
    have h_main : a < c := by
      have h3 : a â‰¤ c := by
        have h4 : a â‰¤ b := h1
        have h5 : b â‰¤ c := h2
        have h6 : a â‰¤ c := le_trans h4 h5
        hole_3
      have h7 : a â‰  c := h
      have h8 : a < c := by
        have h9 : a â‰¤ c := h3
        have h10 : a â‰  c := h7
        hole_4
      hole_2
    have h_final : a â‰¤ c := by
      have h11 : a < c := h_main
      have h12 : a â‰¤ c := le_of_lt h11
      hole_5
    hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 5 sorries
  - Server found sorry at position=(20, 8), proof_state=0
  - Server found sorry at position=(25, 8), proof_state=1
  - Server found sorry at position=(26, 6), proof_state=2
  - Server found sorry at position=(30, 6), proof_state=3
  - Server found sorry at position=(31, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 20:9) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 25:9) to server proof_state 1
  âœ… Matched parser sorry_idx 2 (pos 26:7) to server proof_state 2
  âœ… Matched parser sorry_idx 3 (pos 30:7) to server proof_state 3
  âœ… Matched parser sorry_idx 4 (pos 31:5) to server proof_state 4
ğŸ“Š Correctly matched 5 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_3)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_3
    âœ… linarith succeeded on proof_state 0
  âœ… linarith succeeded on hole_3
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_4)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_4
    âŒ linarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case h
a b c : â„•
h1 : a â‰¤ b
h2 : b â‰¤ c
h : Â¬a = ...
  âŒ linarith failed on hole_4
    âŒ nlinarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case h
a b c : â„•
h1 : a â‰¤ b
h2 : b â‰¤ c
h : Â¬a = ...
  âŒ nlinarith failed on hole_4
    âœ… omega succeeded on proof_state 1
  âœ… omega succeeded on hole_4
ğŸ¯ Testing tactics on sorry index 2 (Hole: hole_2)
    âŒ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remainBuild completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 69 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 63 ms
Completed successfully!
Build completed successfully.

  âŒ norm_num failed on hole_2
    âœ… linarith succeeded on proof_state 2
  âœ… linarith succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 3 (Hole: hole_5)
    âŒ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_5
    âœ… linarith succeeded on proof_state 3
  âœ… linarith succeeded on hole_5
ğŸ¯ Testing tactics on sorry index 4 (Hole: hole_1)
    âŒ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_1
    âœ… linarith succeeded on proof_state 4
  âœ… linarith succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 12
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_4: SOLVED with 'omega'
    âŒ norm_num
    âŒ linarith
    âŒ nlinarith
    âœ… omega
  - hole_2: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_5: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_1: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_3 -> linarith
  âœ… hole_4 -> omega
  âœ… hole_2 -> linarith
  âœ… hole_5 -> linarith
  âœ… hole_1 -> linarith
  ğŸ“Š Replaced 5/5 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 5 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p5/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p5/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 12
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: âœ…
  Processing time: 11.9s

--- Processing 5/9: demo_complex_p6 ---

ğŸ¯ Processing demo/demo_complex_p6 with minimal verification
âŒ Error processing demo_complex_p6: Decomposition results not found: decomposition_results/demo/decomposed/demo_complex_p6/decomposition.json
Please run the original decomposition pipeline first:
python decompose_hole_merge_pipeline.py problem demo demo_complex_p6

--- Processing 6/9: demo_complex_p2 ---

ğŸ¯ Processing demo/demo_complex_p2 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 2 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_1) -> ENUM
  ğŸ“Š 2 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_2" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem case_analysis_simple (n : â„•) : n = 0 âˆ¨ n > 0 := by
  cases' n with k
  Â· 
    left
    have h1 : 0 = 0 := rfl
    exact h1
  Â· 
    right
    have h1 : k + 1 > 0 := by hole_2
    have h2 : Nat.succ k = k + 1 := rfl
    have h3 : k + 1 > 0 := h1
    hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 2 sorries
  - Server found sorry at position=(15, 30), proof_state=0
  - Server found sorry at position=(18, 4), proof_state=1

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 15:31) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 18:5) to server proof_state 1
ğŸ“Š Correctly matched 2 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_2)
    âœ… norm_num succeeded on proof_state 0
  âœ… norm_num succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_1)
    âœ… norm_num succeeded on proof_state 1
  âœ… norm_num succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 2/2
  Success rate (per sorry): 100.0%
  Total proof state tests: 2
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'norm_num'
    âœ… norm_num
  - hole_1: SOLVED with 'norm_num'
    âœ… norm_num
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_2 -> norm_num
  âœ… hole_1 -> norm_num
  ğŸ“Š Replaced 2/2 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 2 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p2/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p2/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 2
  Successful tactics: 2
  Tactics replaced: 2
  Constraint satisfied: âœ…
  Processing time: 10.9s

--- Processing 7/9: demo_eq_comm ---

ğŸ¯ Processing demo/demo_eq_comm with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: FAIL
  Hole: FAIL
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 2 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_1) -> ENUM
  ğŸ“Š 2 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib


macro "hole_2" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem eq_comm_demo (x y : â„•) : x = y â†” y = x := by
  constructor
  Â· 
    have a: x = y -> y = x := by
      hole_2
    hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 2 sorries
  - Server found sorry at position=(11, 6), proof_state=0
  - Server found sorry at position=(12, 4), proof_state=1

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 11:7) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 12:5) to server proof_state 1
ğŸ“Š Correctly matched 2 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_2)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_2
    âŒ linarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
x y : â„•
âŠ¢ False failed...
  âŒ linarith failed on hole_2
    âŒ nlinarith failed on proof_state 0: Lean error:
linarith failed to find a contradiction
x y : â„•
âŠ¢ False failed...
  âŒ nlinarith failed on hole_2
    âœ… omega succeeded on proof_state 0
  âœ… omega succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_1)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_1
    âŒ linarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case mp
x y : â„•
a : x = y â†’ y = x
âŠ¢ False failed...
  âŒ linarith failed on hole_1
    âŒ nlinarith failed on proof_state 1: Lean error:
linarith failed to find a contradiction
case mp
x y : â„•
a : x = y â†’ y = x
âŠ¢ False failed...
  âŒ nlinarith failed on hole_1
    âœ… omega succeeded on proof_state 1
  âœ… omega succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 2/2
  Success rate (per sorry): 100.0%Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 61 ms
Completed successfully!
Build completed successfully.
Build completed successfully.
No files to download
Decompressing 6641 file(s)
Unpacked in 87 ms
Completed successfully!
Build completed successfully.

  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'omega'
    âŒ norm_num
    âŒ linarith
    âŒ nlinarith
    âœ… omega
  - hole_1: SOLVED with 'omega'
    âŒ norm_num
    âŒ linarith
    âŒ nlinarith
    âœ… omega
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_2 -> omega
  âœ… hole_1 -> omega
  ğŸ“Š Replaced 2/2 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 2 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_eq_comm/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: FAIL
  âœ¨ Complete solve success: False
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_eq_comm/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 2
  Tactics replaced: 2
  Constraint satisfied: âœ…
  Processing time: 11.3s

--- Processing 8/9: demo_complex_p7 ---

ğŸ¯ Processing demo/demo_complex_p7 with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: FAIL
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 5 sorry mappings
    0: hole_i (hole_3) -> ENUM
    1: hole_i (hole_2) -> ENUM
    2: hole_i (hole_5) -> ENUM
    3: hole_i (hole_4) -> ENUM
    4: hole_i (hole_1) -> ENUM
  ğŸ“Š 5 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib



macro "hole_3" : tactic => `(tactic| admit)
macro "hole_2" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem simp_then_have_chain (x y : â„•) (h : x + 0 = y + 0) : x = y := by
  simp at h
  have h1 : x â‰¤ y âˆ¨ y â‰¤ x := le_total x y
  cases' h1 with h_le h_ge
  Â· 
    have h2 : x = y := by
      have h3 : x â‰¤ y := h_le
      have h4 : y â‰¤ x := by
        hole_3
      hole_2
    exact h2
  Â· 
    have h2 : x = y := by
      have h3 : y â‰¤ x := h_ge
      have h4 : x â‰¤ y := by
        hole_5
      hole_4
    hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 5 sorries
  - Server found sorry at position=(18, 8), proof_state=0
  - Server found sorry at position=(19, 6), proof_state=1
  - Server found sorry at position=(25, 8), proof_state=2
  - Server found sorry at position=(26, 6), proof_state=3
  - Server found sorry at position=(27, 4), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 18:9) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 19:7) to server proof_state 1
  âœ… Matched parser sorry_idx 2 (pos 25:9) to server proof_state 2
  âœ… Matched parser sorry_idx 3 (pos 26:7) to server proof_state 3
  âœ… Matched parser sorry_idx 4 (pos 27:5) to server proof_state 4
ğŸ“Š Correctly matched 5 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_3)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_3
    âœ… linarith succeeded on proof_state 0
  âœ… linarith succeeded on hole_3
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_2)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_2
    âœ… linarith succeeded on proof_state 1
  âœ… linarith succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 2 (Hole: hole_5)
    âŒ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_5
    âœ… linarith succeeded on proof_state 2
  âœ… linarith succeeded on hole_5
ğŸ¯ Testing tactics on sorry index 3 (Hole: hole_4)
    âŒ norm_num failed on proof_state 3: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_4
    âœ… linarith succeeded on proof_state 3
  âœ… linarith succeeded on hole_4
ğŸ¯ Testing tactics on sorry index 4 (Hole: hole_1)
    âŒ norm_num failed on proof_state 4: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_1
    âœ… linarith succeeded on proof_state 4
  âœ… linarith succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 10
  --- Detailed Tactic Results ---
  - hole_3: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_2: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_5: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_4: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_1: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_3 -> linarith
  âœ… hole_2 -> linarith
  âœ… hole_5 -> linarith
  âœ… hole_4 -> linarith
  âœ… hole_1 -> linarith
  ğŸ“Š Replaced 5/5 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 5 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_complex_p7/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_complex_p7/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 10
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: âœ…
  Processing time: 12.5s

--- Processing 9/9: demo_multiline_have ---

ğŸ¯ Processing demo/demo_multiline_have with minimal verification
ğŸ“‹ Loading existing decomposition results...
ğŸ“Š Existing verification results:
  Original: PASS
  Hole: PASS
Skipping re-verification
ğŸ§ª ProofStep enumeration phase (proof state testing only)...
Pipeline initialized with output directory: decomposition_results
  ğŸ” Found 5 sorry mappings
    0: hole_i (hole_2) -> ENUM
    1: hole_i (hole_4) -> ENUM
    2: hole_i (hole_3) -> ENUM
    3: hole_i (hole_5) -> ENUM
    4: hole_i (hole_1) -> ENUM
  ğŸ“Š 5 enumerable holes, 0 skip holes
ğŸš€ Starting ProofStep enumeration with proof states
Enumerable indices: [0, 1, 2, 3, 4]
Tactics to test: ['norm_num', 'linarith', 'nlinarith', 'omega', 'ring', 'ring_nf', 'simp', 'simpa', 'field_simp', 'positivity', 'norm_cast']

--- Analyzing Lean Code for Proof States ---
import Mathlib

macro "hole_2" : tactic => `(tactic| admit)
macro "hole_4" : tactic => `(tactic| admit)
macro "hole_3" : tactic => `(tactic| admit)
macro "hole_5" : tactic => `(tactic| admit)
macro "hole_1" : tactic => `(tactic| admit)

theorem multiline_have_test (n : â„•) (h : n > 0) : n + n â‰¥ n := by
  have h1 : n â‰¥ 1 := by
    hole_2
  have h2 : n + n â‰¥ 
        n + 1 := by
    have h3 : n â‰¥ 1 := h1
    have h4 : n + n = 
          n + n := rfl
    have h5 : n + 1 â‰¤ 
        n + n := by
      hole_4
    hole_3
  have h6 : n + 1 â‰¥ 
      n := by
    hole_5
  hole_1
------------------------------------------
ğŸ“Š ProofStep response received: 5 sorries
  - Server found sorry at position=(12, 4), proof_state=0
  - Server found sorry at position=(20, 6), proof_state=1
  - Server found sorry at position=(21, 4), proof_state=2
  - Server found sorry at position=(24, 4), proof_state=3
  - Server found sorry at position=(25, 2), proof_state=4

--- Matching Parser Sorries to Server Proof States ---
  âœ… Matched parser sorry_idx 0 (pos 12:5) to server proof_state 0
  âœ… Matched parser sorry_idx 1 (pos 20:7) to server proof_state 1
  âœ… Matched parser sorry_idx 2 (pos 21:5) to server proof_state 2
  âœ… Matched parser sorry_idx 3 (pos 24:5) to server proof_state 3
  âœ… Matched parser sorry_idx 4 (pos 25:3) to server proof_state 4
ğŸ“Š Correctly matched 5 proof states for enumeration.
ğŸ¯ Testing tactics on sorry index 0 (Hole: hole_2)
    âŒ norm_num failed on proof_state 0: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_2
    âœ… linarith succeeded on proof_state 0
  âœ… linarith succeeded on hole_2
ğŸ¯ Testing tactics on sorry index 1 (Hole: hole_4)
    âŒ norm_num failed on proof_state 1: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_4
    âœ… linarith succeeded on proof_state 1
  âœ… linarith succeeded on hole_4
ğŸ¯ Testing tactics on sorry index 2 (Hole: hole_3)
    âŒ norm_num failed on proof_state 2: Incomplete: open goals remain, 1 goals remain
  âŒ norm_num failed on hole_3
    âœ… linarith succeeded on proof_state 2
  âœ… linarith succeeded on hole_3
ğŸ¯ Testing tactics on sorry index 3 (Hole: hole_5)
    âœ… norm_num succeeded on proof_state 3
  âœ… norm_num succeeded on hole_5
ğŸ¯ Testing tactics on sorry index 4 (Hole: hole_1)
    âœ… norm_num succeeded on proof_state 4
  âœ… norm_num succeeded on hole_1
ğŸ“ˆ ProofStep Results:
  Solved sorries: 5/5
  Success rate (per sorry): 100.0%
  Total proof state tests: 8
  --- Detailed Tactic Results ---
  - hole_2: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_4: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_3: SOLVED with 'linarith'
    âŒ norm_num
    âœ… linarith
  - hole_5: SOLVED with 'norm_num'
    âœ… norm_num
  - hole_1: SOLVED with 'norm_num'
    âœ… norm_num
  Full verifications used: 0/3
ğŸ“ Creating synthesized version by directly replacing holes with tactics...
  âœ… hole_2 -> linarith
  âœ… hole_4 -> linarith
  âœ… hole_3 -> linarith
  âœ… hole_5 -> norm_num
  âœ… hole_1 -> norm_num
  ğŸ“Š Replaced 5/5 hole usages with tactics/admit
  ğŸ—‚ï¸  Complete tactic mapping: 5 holes mapped
  ğŸ¯ No admits used: True
  ğŸ’¾ Synthesized proof saved to: decomposition_results/demo/decomposed/demo_multiline_have/synthesized_proof.lean
ğŸ” Verification 3: Final synthesized proof
ğŸ” Full verification #1: final synthesized proof
Pipeline initialized with output directory: decomposition_results
  Result: PASS
  âœ¨ Complete solve success: True
  ğŸ’¾ Minimal verification result saved to: decomposition_results/demo/decomposed/demo_multiline_have/minimal_verification.json
ğŸ“Š Results:
  Verifications: 1/3
  Proof state tests: 8
  Successful tactics: 5
  Tactics replaced: 5
  Constraint satisfied: âœ…
  Processing time: 12.0s
ğŸ’¾ Dataset summary saved to: decomposition_results/demo_minimal_verification_summary.json

================================================================================
ğŸ‰ MINIMAL VERIFICATION PIPELINE SUMMARY
Dataset: demo
Problems processed: 9
Constraint violations: 1
Constraint satisfaction rate: 88.9%
Successfully filled proofs: 7
Complete solve success (no admits): 7
Complete solve success rate: 77.8%
Total proof state tests: 62
Total full verifications: 8
Verification efficiency: 7.8 proof state tests per full verification

âš ï¸  1 constraint violations detected
                                                                                Saving trace data, this could take a while                                                                                Wait for child processes to finish, Ctrl+C to skip                                                                                Loading trace data from processes 0/1