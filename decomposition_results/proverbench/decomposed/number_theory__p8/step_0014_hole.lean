theorem h₂ (x y z : ℕ) (h : x * y = z ^ 2 + 1) (h₁ : x = 1 ∧ y = z ^ 2 + 1 ∨ x = z ^ 2 + 1 ∧ y = 1 ∨ ∃ a b, (↑x : ℤ) = a ^ 2 + b ^ 2 ∧ y = 1) : ∃ a b c d, (↑x : ℤ) = a ^ 2 + b ^ 2 ∧ (↑y : ℤ) = c ^ 2 + d ^ 2 ∧ (↑z : ℤ) = a * c + b * d := by
  --  cases h₁ with
  --  | inl h₁ =>
  --    have h₃ : x = 1 := h₁.1
  --    have h₄ : y = z ^ 2 + 1 := h₁.2
  --    use 1, 0, z, 1
  --    have h₅ : (x : ℤ) = 1 := by norm_cast <;> simp [h₃]
  --    have h₆ : (y : ℤ) = z ^ 2 + 1 := by norm_cast <;> simp [h₄]
  --    have h₇ : (z : ℤ) = z := by simp
  --    constructor
  --    · norm_num [h₅]
  --    · constructor
  --      · norm_num [h₆] <;> ring_nf <;> simp [h₇] <;> nlinarith
  --      · norm_num [h₅, h₆, h₇] <;> ring_nf <;> simp [h₃, h₄] <;> nlinarith
  --  | inr h₁ =>
  --    cases h₁ with
  --    | inl h₁ =>
  --      have h₃ : x = z ^ 2 + 1 := h₁.1
  --      have h₄ : y = 1 := h₁.2
  --      use z, 1, 1, 0
  --      have h₅ : (x : ℤ) = z ^ 2 + 1 := by norm_cast <;> simp [h₃]
  --      have h₆ : (y : ℤ) = 1 := by norm_cast <;> simp [h₄]
  --      have h₇ : (z : ℤ) = z := by simp
  --      constructor
  --      · norm_num [h₅, h₇] <;> ring_nf <;> simp [h₃] <;> nlinarith
  --      · constructor
  --        · norm_num [h₆]
  --        · norm_num [h₅, h₆, h₇] <;> ring_nf <;> simp [h₃, h₄] <;> nlinarith
  --    | inr h₁ =>
  --      obtain ⟨a, b, h₂, h₃⟩ := h₁
  --      use a, b, 1, 0
  --      have h₄ : (x : ℤ) = a ^ 2 + b ^ 2 := by
  --        norm_num at h₂ ⊢ <;> (try norm_cast) <;> (try simp_all) <;> (try ring_nf at * <;> nlinarith)
  --      have h₅ : (y : ℤ) = 1 := by
  --        norm_num at h₃ ⊢ <;> (try norm_cast) <;> (try simp_all) <;> (try ring_nf at * <;> nlinarith)
  --      have h₆ : (z : ℤ) = z := by simp
  --      constructor
  --      · exact h₄
  --      · constructor
  --        · norm_num [h₅]
  --        ·
  --          have h₇ : (z : ℤ) = a * 1 + b * 0 :=
  --            by
  --            have h₇₁ : (x : ℕ) * y = z ^ 2 + 1 := by simpa using h
  --            have h₇₂ : x = 1 := by
  --              norm_num [h₃] at h₂ ⊢ <;> (try norm_cast at h₂ ⊢) <;> (try simp_all) <;> (try ring_nf at * <;> nlinarith)
  --            have h₇₃ : y = 1 := by
  --              norm_num [h₃] at h₂ ⊢ <;> (try norm_cast at h₂ ⊢) <;> (try simp_all) <;> (try ring_nf at * <;> nlinarith)
  --            have h₇₄ : z = 0 := by
  --              norm_num [h₃, h₇₂, h₇₃] at h₇₁ ⊢ <;> (try norm_cast at h₇₁ ⊢) <;> (try simp_all) <;>
  --                (try ring_nf at * <;> nlinarith)
  --            norm_num [h₇₄, h₄, h₅, h₆] at h₂ ⊢ <;> (try norm_cast at h₂ ⊢) <;> (try simp_all) <;>
  --              (try ring_nf at * <;> nlinarith)
  --          simp_all [add_assoc] <;> ring_nf at * <;> nlinarith
  hole