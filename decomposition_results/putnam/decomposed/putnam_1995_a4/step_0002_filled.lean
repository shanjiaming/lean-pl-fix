theorem h_main (n : ℕ) (hn : n > 0) (necklace : Fin n → ℤ) (hnecklacesum : ∑ i, necklace i = (↑n : ℤ) - 1) : ∃ cut, ∀ (k : ℕ), ∑ i, necklace (cut + (↑i : Fin n)) ≤ (↑k : ℤ) := by
  --  classical
  --  have h₁ : ∃ (cut : Fin n), necklace cut ≤ 0 := by
  --    by_contra! h
  --    have h₂ : ∀ i : Fin n, necklace i > 0 := by simpa using h
  --    have h₃ : ∑ i : Fin n, necklace i > 0 := by
  --      calc
  --        ∑ i : Fin n, necklace i ≥ ∑ i : Fin n, 1 := by
  --          exact
  --            Finset.sum_le_sum fun i _ => by
  --              have := h₂ i
  --              linarith
  --        _ = n := by simp [Finset.sum_const, Finset.card_fin]
  --        _ > 0 := by norm_num <;> omega
  --        _ > 0 := by norm_num
  --    have h₄ : (n : ℤ) - 1 ≥ 0 :=
  --      by
  --      have h₅ : (n : ℤ) ≥ 1 := by exact_mod_cast Nat.succ_le_iff.mpr hn
  --      linarith
  --    linarith
  --  obtain ⟨cut, hcut⟩ := h₁
  --  refine' ⟨cut, _⟩
  --  intro k
  --  have h₂ : ∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) ≤ k :=
  --    by
  --    have h₃ : ∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) ≤ k :=
  --      by
  --      have h₄ :
  --        ∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) = ∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) := rfl
  --      rw [h₄]
  --      have h₅ : ∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) ≤ k := by
  --        calc
  --          (∑ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i)) ≤ ∑ i : { j : Fin n // j.1 ≤ k }, (1 : ℤ) :=
  --            by
  --            have h₆ : ∀ i : { j : Fin n // j.1 ≤ k }, necklace (cut + i) ≤ 1 :=
  --              by
  --              intro i
  --              have h₇ : necklace (cut + i) ≤ 1 := by
  --                by_contra h₈
  --                have h₉ : necklace (cut + i) > 1 := by linarith
  --                have h₁₀ : ∑ i : Fin n, necklace i > n - 1 := by
  --                  calc
  --                    ∑ i : Fin n, necklace i ≥ necklace (cut + i) :=
  --                      by
  --                      have h₁₁ : ∑ i : Fin n, necklace i ≥ necklace (cut + i) :=
  --                        by
  --                        have h₁₂ : (cut + i : Fin n) ∈ (Finset.univ : Finset (Fin n)) := by apply Finset.mem_univ
  --                        have h₁₃ : necklace (cut + i) ≤ ∑ i : Fin n, necklace i := by
  --                          apply
  --                            Finset.single_le_sum
  --                              (fun i _ => by
  --                                have h₁₄ : necklace i ≥ necklace i := by linarith
  --                                linarith)
  --                              h₁₂
  --                        linarith
  --                      linarith
  --                    _ > n - 1 :=
  --                      by
  --                      have h₁₅ : (n : ℤ) - 1 ≥ 0 :=
  --                        by
  --                        have h₁₆ : (n : ℤ) ≥ 1 := by exact_mod_cast Nat.succ_le_iff.mpr hn
  --                        linarith
  --                      have h₁₇ : necklace (cut + i) > 1 := by linarith
  --                      have h₁₈ : (n : ℤ) - 1 < n :=
  --                        by
  --                        have h₁₉ : (n : ℤ) - 1 < n := by omega
  --                        linarith
  --                      have h₂₀ : necklace (cut + i) > 1 := by linarith
  --                      have h₂₁ : (n : ℤ) - 1 < n := by omega
  --                      omega
  --                linarith
  --              linarith
  --            exact
  --              Finset.sum_le_sum fun i _ => by
  --                have h₇ := h₆ i
  --                linarith
  --          _ = ∑ i : { j : Fin n // j.1 ≤ k }, (1 : ℤ) := by rfl
  --          _ = (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card := by simp [Finset.sum_const]
  --          _ ≤ k :=
  --            by
  --            have h₈ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 :=
  --              by
  --              have h₉ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 :=
  --                by
  --                have h₁₀ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ (Finset.univ : Finset (Fin n)).card :=
  --                  by
  --                  apply Finset.card_le_card
  --                  intro i
  --                  simp [Finset.mem_univ] <;> aesop
  --                have h₁₁ : (Finset.univ : Finset (Fin n)).card = n := by simp
  --                have h₁₂ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ n := by linarith
  --                have h₁₃ : n ≤ k + 1 := by
  --                  by_cases h₁₄ : k + 1 ≥ n
  --                  · omega
  --                  · exfalso
  --                    have h₁₅ : k + 1 < n := by omega
  --                    have h₁₆ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 :=
  --                      by
  --                      have h₁₇ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 :=
  --                        by
  --                        have h₁₈ :
  --                          (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤
  --                            (Finset.Icc (⟨0, by omega⟩ : Fin n) ⟨k, by omega⟩).card :=
  --                          by
  --                          apply Finset.card_le_card
  --                          intro i
  --                          simp [Finset.mem_univ, Finset.mem_Icc] <;> aesop
  --                        have h₁₉ : (Finset.Icc (⟨0, by omega⟩ : Fin n) ⟨k, by omega⟩).card ≤ k + 1 :=
  --                          by
  --                          have h₂₀ : (Finset.Icc (⟨0, by omega⟩ : Fin n) ⟨k, by omega⟩).card ≤ k + 1 := by
  --                            simp [Finset.Icc_eq_empty, Finset.card_eq_zero, Nat.lt_succ_iff] <;> omega
  --                          exact h₂₀
  --                        linarith
  --                      exact h₁₇
  --                    omega
  --                omega
  --              exact h₉
  --            have h₁₀ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 := by exact h₈
  --            have h₁₁ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k :=
  --              by
  --              by_cases h₁₂ : k ≥ n
  --              ·
  --                have h₁₃ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ n :=
  --                  by
  --                  have h₁₄ :
  --                    (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ (Finset.univ : Finset (Fin n)).card :=
  --                    by
  --                    apply Finset.card_le_card
  --                    intro i
  --                    simp [Finset.mem_univ] <;> aesop
  --                  have h₁₅ : (Finset.univ : Finset (Fin n)).card = n := by simp
  --                  linarith
  --                have h₁₆ : (n : ℕ) ≤ k := by omega
  --                have h₁₇ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k := by omega
  --                exact h₁₇
  --              ·
  --                have h₁₈ : k < n := by omega
  --                have h₁₉ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 := by exact h₁₀
  --                have h₂₀ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k :=
  --                  by
  --                  by_cases h₂₁ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k
  --                  · exact h₂₁
  --                  · exfalso
  --                    have h₂₂ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card > k := by omega
  --                    have h₂₃ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k + 1 := by exact h₁₀
  --                    omega
  --                exact h₂₀
  --            have h₂₁ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k := by exact h₁₁
  --            have h₂₂ : (Finset.univ : Finset { j : Fin n // j.1 ≤ k }).card ≤ k := by exact h₁₁
  --            simp_all [Finset.sum_const, nsmul_eq_mul, mul_comm] <;> omega <;>
  --                simp_all [Finset.sum_const, nsmul_eq_mul, mul_comm] <;>
  --              omega
  --      exact h₅
  --    exact h₃
  --  exact h₂
  hole